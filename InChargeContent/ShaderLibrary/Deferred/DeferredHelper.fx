//-----------------------------------------------
// Synapse Gaming - SunBurn Lighting System
// Copyright © Synapse Gaming 2008
//-----------------------------------------------


//-----------------------------------------------
// Used to scale g-buffer and lighting
// information into potentially non-floating
// point g-buffers.
// 
// Do not change: these values are also compiled
// into SunBurn's internal shaders, changing
// these will create a mismatch between data
// generated by SunBurn and loaded by your
// shaders.
//

#define SpecularGeneralRange	2.0f
#define LightingRange			4.0f


//-----------------------------------------------
// Structures used to load and save g-buffer
// and lighting data.
//

// SunBurn g-buffer structure.
struct SceneMRTData
{
	float4 depthAndSpecularPower	: COLOR0;
	float4 viewNormalAndSpecular	: COLOR1;
};

// SunBurn lighting structure.
struct LightingMRTData
{
	float4 lightingDiffuse		: COLOR0;
	float4 lightingSpecular		: COLOR1;
};


//-----------------------------------------------
// SunBurn custom SAS parameters used by the
// library shader functions.
// 
// These parameters are automatically bound by
// SunBurn custom SAS effects.
//

float _FarClippingDistance : FARCLIPDIST = 0.0f;
float4 _TransClipRef : RENDERINFO = {0, 0, 0, 0};
float4 _OffsetBias_DepthBias_TransClipRef : SHADOWINFO = {0, 0, 0, 0};
float4 _Direction_Or_Position_And_Radius : SHADOWSOURCE = {0, 0, 0, 0};
float2 _TargetWidthHeight : TARGETINFO = {0, 0};
float2 _FogStartDist_EndDistInv : FOGINFO = {0, 0};
float3 _FogColor : FOGCOLOR = {0, 0, 0};

float3 _CompositeLightingAmbient : COMPOSITELIGHTINGAMBIENT = float3(0.0f, 0.0f, 0.0f);
float3 _CompositeLightingDiffuse : COMPOSITELIGHTINGDIFFUSE = float3(0.0f, 0.0f, 0.0f);
float3 _CompositeLightingDirection : COMPOSITELIGHTINGDIRECTION = float3(0.0f, 0.0f, 0.0f);

texture _LightMapTexture : LIGHTMAPTEXTURE;

sampler LightMapSampler = sampler_state
{
    Texture = <_LightMapTexture>;
};


//-----------------------------------------------
// Calculates the distance between a position
// and the current shadow source.
//
// worldpos - world position to compare
// with the current shadow source.
//
// returns - distance between a position
// and the current shadow source.
//

float GetShadowDistance(float3 worldpos)
{
	return saturate(length(worldpos - _Direction_Or_Position_And_Radius.xyz) / _Direction_Or_Position_And_Radius.w);
}


//-----------------------------------------------
// Calculates the shadow distance (depth) of a
// pixel including the shadow bias offsets.
// 
// Used when rendering into a shadow map.
//
// worldpos - world position of the pixel
// being rendered into the shadow map.
//
// returns - distance (depth) of the pixel
// from the shadow source including the shadow
// bias offsets.
//

float4 GetShadowMapDepth(float3 worldpos)
{
	float depth = GetShadowDistance(worldpos);
	return depth + (_OffsetBias_DepthBias_TransClipRef.y * 0.01 + fwidth(depth) * _OffsetBias_DepthBias_TransClipRef.x);
}


//-----------------------------------------------
// Calculates the shadow distance (depth) of a
// pixel including the shadow bias offsets.
//
// Also applies alpha clipping based on the
// material's diffuse texture.
// 
// Used when rendering into a shadow map.
//
// worldpos - world position of the pixel
// being rendered into the shadow map.
//
// diffuse - sample from the diffuse texture
// of the rendered material.
//
// returns - distance (depth) of the pixel
// from the shadow source including the shadow
// bias offsets.
//

float4 GetShadowMapDepthAndClipTransparency(float3 worldpos, float4 diffuse)
{
	float alpha = (diffuse.w - _OffsetBias_DepthBias_TransClipRef.z);
	clip(alpha);

	return GetShadowMapDepth(worldpos);
}


//-----------------------------------------------
// Applies alpha clipping to a material.
//
// diffuse - sample from the diffuse texture
// of the rendered material.
//

void ClipTransparency(float4 diffuse)
{
	float alpha = (diffuse.w - _TransClipRef.x);
	clip(alpha);
}


//-----------------------------------------------
// Calculates the uv coordinates for a full
// screen texture (as if rendered with a
// full screen quad).
//
// projectionpos - location in projection space
// where the pixel will rendered.
//
// returns - the location's on-screen uv
// coordinates (as if rendered with a full
// screen quad).
//

float2 GetScreenUV(float4 projectionpos)
{
	float4 pos = projectionpos / projectionpos.w;
	float2 uv = pos.xy * 0.5f + 0.5f;

	uv.y = 1.0f - uv.y;
	uv  += (0.5f / _TargetWidthHeight.xy);
	
	return uv;
}


//-----------------------------------------------
// Calculates the linear depth (used by the
// g-buffers and SaveSceneData).
//
// viewpos - view space position of the current
// pixel.
//

float GetLinearDepth(float3 viewpos)
{
    return viewpos.z / _FarClippingDistance;
}


//-----------------------------------------------
// Calculates the full view-space position
// (including depth) of a deferred depth value.
//
// viewpos - view-space position of the object
// currently rendering to the screen (often full
// screen quad).
//
// depth - view-space linear depth value sampled
// from a texture projected onto the currently
// rendered object.
//
// returns - full view-space position.
//

float4 GetViewPosition(float3 viewpos, float lineardepth)
{
	float3 ray = viewpos.xyz * (_FarClippingDistance / viewpos.z);
    return float4(lineardepth * ray, 1.0f);
}


float3 GetCompositeLighting(float3 worldnormal)
{
	float angleattn = saturate(dot(-worldnormal, _CompositeLightingDirection));
	return _CompositeLightingAmbient + _CompositeLightingDiffuse * angleattn;
}


float3 GetLightMapLighting(float2 uniqueuv)
{
	return tex2D(LightMapSampler, uniqueuv) * 2.0f;
}


//-----------------------------------------------
// Combines a material's diffuse and specular
// textures with the deferred lighting diffuse
// and specular amount to illuminate the pixel.
//
// materialdiffuse - sample from the diffuse texture
// of the rendered material.
//
// materialspecular - sample from the specular-color
// texture of the rendered material.
//
// lightingdiffuse - sample from the deferred
// lighting diffuse texture.
//
// lightingspecular - sample from the deferred
// lighting specular texture.
//
// returns - illuminated pixel color.
//

float3 LightMaterial(float3 materialdiffuse, float3 materialspecular, float3 lightingdiffuse, float3 lightingspecular)
{
	return materialdiffuse * lightingdiffuse + materialspecular * lightingspecular;
}


//-----------------------------------------------
// Applies fog to a material.
//
// materialcolor - complete material color
// including all lighting and textures.
//
// viewpos - view-space position of the
// current pixel.
//
// returns - material color combined with
// fog amount.
//

float3 FogMaterial(float3 materialcolor, float3 viewpos)
{
	float amount = saturate((length(viewpos) - _FogStartDist_EndDistInv.x) * _FogStartDist_EndDistInv.y);
	
	return lerp(materialcolor, _FogColor, amount);
}


//-----------------------------------------------
// Provides automatic multi-sampling and
// anti-aliasing when sampling a texture.
//
// Used to apply multi-sampling to deferred
// lighting diffuse and specular textures.
//
// gbuffer - texture sampler to multi-sample from.
//
// uv_linear - linear interpolated uv coordinates
// using the standard TEXCOORD<n> semantic.
//
// uv_centroid - centroid interpolated uv
// coordinates using the TEXCOORD<n>_centroid semantic.
//
// returns - the multi-sampled value for the texture.
//

float4 MultiSampleGBuffer(sampler gbuffer, float2 uv_linear, float2 uv_centroid)
{
	float2 uv = uv_centroid + (uv_linear - uv_centroid) * 3.0f;	
	return tex2D(gbuffer, uv);
}


//-----------------------------------------------
// Provides automatic packing of data into the
// SunBurn g-buffer structure.
//
// Used when rendering information to deferred
// g-buffers.
//

SceneMRTData SaveSceneData(float3 viewnormal, float lineardepth,
	float spec_power, float3 fresnel_bias_offset_microfacet)
{
	SceneMRTData output = (SceneMRTData)0;
	
	
	// pack view normal...
	float2 spherical;
	spherical.x = atan2(viewnormal.y, viewnormal.x);
	spherical.y = acos(viewnormal.z);
	
	spherical /= 3.14159f;
	spherical.x = spherical.x * 0.5f + 0.5f;
	
	output.viewNormalAndSpecular.xy = spherical;
	
	
	// pack linear depth...
	output.depthAndSpecularPower.x = lineardepth;
	
	
	// pack specular...
	output.depthAndSpecularPower.y = spec_power;
	output.viewNormalAndSpecular.zw = fresnel_bias_offset_microfacet.xz / float2(SpecularGeneralRange, 1.0f);
	
	
	return output;
}


//-----------------------------------------------
// Provides automatic unpacking of data from the
// SunBurn g-buffer structure.
//
// Used when sampling information from deferred
// g-buffers.
//

void LoadSceneData(SceneMRTData input, out float3 viewnormal, out float lineardepth,
	out float spec_power, out float3 fresnel_bias_offset_microfacet)
{
	// unpack view normal...
	float2 spherical = input.viewNormalAndSpecular.xy;
	
	spherical.x = spherical.x * 2.0f - 1.0f;
	spherical *= 3.14159f;
	
	float sin_y = sin(spherical.y);
	viewnormal.x = cos(spherical.x) * sin_y;
	viewnormal.y = sin(spherical.x) * sin_y;
	viewnormal.z = cos(spherical.y);
	
	
	// unpack linear depth (range: 0 to -1)...
	lineardepth = input.depthAndSpecularPower.x;
	
	
	// unpack specular...
	spec_power = input.depthAndSpecularPower.y;
	fresnel_bias_offset_microfacet = input.viewNormalAndSpecular.zzw * float3(SpecularGeneralRange, SpecularGeneralRange, 1.0f);
}


//-----------------------------------------------
// Provides automatic packing of data into the
// SunBurn lighting structure.
//
// Used when rendering information to deferred
// lighting buffers.
//

LightingMRTData SaveLightingData(float3 lightingdiffuse, float3 lightingspecular)
{
	LightingMRTData output = (LightingMRTData)0;
	
	float scale = 1.0f / LightingRange;
	output.lightingDiffuse.xyz = scale * lightingdiffuse;
	output.lightingSpecular.xyz = scale * lightingspecular;
	
	return output;
}


//-----------------------------------------------
// Provides automatic unpacking of data from the
// SunBurn lighting structure.
//
// Used when sampling information from deferred
// lighting buffers.
//

void LoadLightingData(LightingMRTData input, out float3 lightingdiffuse, out float3 lightingspecular)
{
	lightingdiffuse = input.lightingDiffuse.xyz * LightingRange;
	lightingspecular = input.lightingSpecular.xyz * LightingRange;
}


//-----------------------------------------------
// Provides automatic multi-sampled lighting
// and material calculations.
//
// scenelightingdiffuse - sampler bound to the deferred
// lighting diffuse texture provided by SunBurn.
//
// scenelightingspecular - sampler bound to the deferred
// lighting specular texture provided by SunBurn.
//
// materialdiffuse - sample from the diffuse texture
// of the rendered material.
//
// materialspecular - sample from the specular-color
// texture of the rendered material.
//
// ambientlighting - current ambient lighting color.
//
// viewposition - view space position of the current
// pixel interpolated using the standard TEXCOORD<n>
// semantic.
//
// projectionposition - projection space position
// of the current pixel interpolated using the
// standard TEXCOORD<n> semantic.
//
// projectionposition_centroid - projection space
// position of the current pixel interpolated using
// the TEXCOORD<n>_centroid semantic.
//

float4 CalculateDefaultLightingAndMaterials(
	sampler scenelightingdiffuse, sampler scenelightingspecular,
	float3 materialdiffuse, float3 materialspecular, float3 ambientlighting,
	float4 viewposition, float4 projectionposition, float4 projectionposition_centroid)
{
	// calculate the screen-space uv coordinates used to sample
	// from the full-screen deferred lighting textures.
	
	float2 screenuvlinear = GetScreenUV(projectionposition);
	float2 screenuvcentroid = GetScreenUV(projectionposition_centroid);
	
	
	// sample the pre-generated deferred lighting textures - use SunBurn's
	// multisampling helper function for anti-aliasing (only recommended for
	// deferred buffers).
	
	LightingMRTData data;
	data.lightingDiffuse = MultiSampleGBuffer(scenelightingdiffuse, screenuvlinear, screenuvcentroid);
	data.lightingSpecular = MultiSampleGBuffer(scenelightingspecular, screenuvlinear, screenuvcentroid);
	
	
	// unpack the lighting data using SunBurn's helper function.
	
	float3 lightingdiffuse = 0.0f;
	float3 lightingspecular = 0.0f;
	
	LoadLightingData(data, lightingdiffuse, lightingspecular);
	
	
	// apply the unpacked lighting and SunBurn's automatic fog to the
	// diffuse, and return the full material color.
	
	float4 material = 0.0f;
	material.xyz = LightMaterial(materialdiffuse, materialspecular, lightingdiffuse + ambientlighting, lightingspecular);
	material.xyz = FogMaterial(material.xyz, viewposition);
	
	return material;
}

//-----------------------------------------------







